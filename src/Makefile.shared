# This Makefile is shared between all demos. It is our suggestion
# of a canonical Makefile for projects that use Objective Caml,
# ocamllex, and couac. It requires GNU make.

# ----------------------------------------------------------------

# This Makefile is meant to be included within a host Makefile
# that defines the following variables:
#
# GENERATED    :  a list of the source (.ml and .mli) files
#                 that should be generated by invoking ocamllex
#                 or couac
#
# MODULES      :  a list of the modules (without extension)
#                 that should be linked into the executable
#                 program. Order is significant.
#
# EXECUTABLE   :  the base name of the executables that should
#                 be produced. Suffixes $(BSUFFIX) and $(OSUFFIX)
#                 will be added to distinguish the bytecode and
#                 native code versions.

# ----------------------------------------------------------------

# The host Makefile can also override the following settings:

# Bytecode compilation flags.
BFLAGS         := 
# Native code compilation flags.
OFLAGS         := 
# Bytecode link-time flags.
BLNKFLAGS      := 
# Native code link-time flags.
OLNKFLAGS      := 
# Parser generation flags.
PGFLAGS        := --infer -v
# Suffix appended to the name of the bytecode executable.
BSUFFIX        := .byte
# Suffix appended to the name of the native code executable.
OSUFFIX        := 
# Access paths.
OCAMLDEP       := ocamldep
OCAMLLEX       := ocamllex
COUAC          := menhir --dump 

# TEMPORARY ne pas hard-coder le chemin relatif de couac
# A list of targets that do not require dependency analysis.
# This variable should be set by the host before including
# this Makefile.
COLD           += clean

# ----------------------------------------------------------------

# Do not destroy the generated source files.

.SECONDARY: $(GENERATED) $(patsubst %.mli,%.mli.d,$(wildcard *.mli)) \
            $(patsubst %.ml,%.ml.d,$(wildcard *.ml)) \
	    $(patsubst %.mll,%.ml.d,$(wildcard *.mll)) 

# ----------------------------------------------------------------

# Linking.

$(EXECUTABLE)$(OSUFFIX): $(MODULES:=.cmx)
	$(OCAMLOPT) -o $(EXECUTABLE)$(OSUFFIX) $(OLNKFLAGS) $(MODULES:=.cmx)

$(EXECUTABLE)$(BSUFFIX): $(MODULES:=.cmo)
	$(OCAMLC) -o $(EXECUTABLE)$(BSUFFIX) $(BLNKFLAGS) $(MODULES:=.cmo)

# ----------------------------------------------------------------

# Compiling.

# We make the .ml and .mli files generated by ocamllex and couac
# unwritable, so as to prevent them from being edited by mistake.

%.cmi: %.mli %.mli.d
	$(OCAMLC) $(BFLAGS) -c $<

%.cmo: %.ml %.ml.d
	$(OCAMLC) $(BFLAGS) -c $<

%.cmx %.o: %.ml %.ml.d
	$(OCAMLOPT) $(OFLAGS) -c $<

%.ml: %.mll
	@/bin/chmod -f +w $@ || true
	$(OCAMLLEX) $<
	@/bin/chmod -w $@

# ----------------------------------------------------------------

# Computing dependencies.

# We associate a tiny Makefile, whose name ends in .d, with every
# source file; it contains dependency information only. For an .ml or
# .mli file, we create an .ml.d or .mli.d file by invoking ocamldep.
# For an .mll file, we create an .ml.d file by invoking ocamllex first
# (this is implicit), then ocamldep.

# When it finds a reference to module M, ocamldep checks whether the
# files m.ml and m.mli exist before deciding which dependency to
# report. If m.ml and m.mli are generated from m.mll or m.mly, then
# there is a potential problem: because ocamldep is invoked before
# these files are created, it cannot see them. The standard solution
# until now was to invoke ocamllex and ocamlyacc first to create all
# generated files, and run ocamldep next. This approach does not work
# with couac when the --infer switch is on: couac cannot be invoked
# first because it needs type information found in .cmi (or .cmo or
# .cmx) files. Our solution is to invoke ocamldep first, and create
# fake generated files m.ml and m.mli to let it know that these files
# are supposed to exist. This is somewhat tricky, but appears to work.

# For a reason that I don't understand, things work better if we do
# not remove the fakes after running ocamldep. (If we do remove them,
# make invokes couac twice, once for building the .mli file and once
# for building the .ml file.) This might be due (in part?) to the
# fact that make sees the fakes via the $wildcard patterns below
# and creates .d files for them earlier (otherwise, they would be
# created only in the second run of make).

make_fakes = \
  /bin/rm -f $@ ; \
  for i in $(GENERATED) ; do \
    if ! [ -f $$i ] ; then \
      /bin/touch -t 197301010000 $$i ; \
    fi ; \
  done

%.ml.d: %.ml
	@$(make_fakes)
	$(OCAMLDEP) $< > $@ 

%.mli.d: %.mli
	@$(make_fakes)
	$(OCAMLDEP) $< > $@

# All .d files are included within the present Makefile, so it they
# do not exist, they are created first, and the dependencies that
# they contain are then taken into account.

ifeq ($(findstring $(MAKECMDGOALS),$(COLD)),)
  ifneq ($(strip $(wildcard *.mli)),)
    -include $(patsubst %.mli,%.mli.d,$(wildcard *.mli))
  endif
  ifneq ($(strip $(wildcard *.ml)),)
    -include $(patsubst %.ml,%.ml.d,$(wildcard *.ml))
  endif
  ifneq ($(strip $(wildcard *.mll)),)
    -include $(patsubst %.mll,%.ml.d,$(wildcard *.mll))
  endif
endif


# ----------------------------------------------------------------

# Support for couac projects.

# The macro couac_multimodule defines support for multi-module grammar
# specifications, that is, for producing parsers out of multiple
# source files. The parameter $(1) is the name of the parser that
# should be produced; the parameter $(2) is the list of .mly source
# files; the parameter $(3) contains extra options to be passed to
# couac.

# The dependency file is named $(1).d and created by invoking couac
# --depend.

define couac_multimodule
$(1).ml $(1).mli: $(2) $(1).d
	@/bin/chmod -f +w $(1).ml $(1).mli || true
	$(COUAC) --ocamlc "$(OCAMLC)" $(PGFLAGS) --base $(1) $(3) $(2)
	@/bin/chmod -w $(1).ml $(1).mli

$(1).d: $(2)
	@/bin/chmod -f +w $(1).ml $(1).mli || true
	@$(make_fakes)
	$(COUAC) --ocamldep "$(OCAMLDEP)" --depend --base $(1) $(3) $(2) > $$@

ifeq ($(findstring $$(MAKECMDGOALS),$$(COLD)),)
-include $(1).d
.SECONDARY: $(1).d
endif
endef

# The macro couac_monomodule defines support for a mono-module grammar
# specification. The parameter $(1) is the name of the parser that
# should be produced; the source file is $(1).mly. The parameter $(2)
# contains extra options to be passed to couac.

define couac_monomodule
$(eval $(call couac_multimodule,$(1),$(1).mly,$(2)))
endef

# Neither of the two macros above is invoked by default, as it is not
# known here which is appropriate. It is up to the client to invoke
# these macros with suitable parameters. The auxiliary Makefile.auto
# implements the common case where every .mly file is a mono-module
# grammar.

# ----------------------------------------------------------------

.PHONY: clean

clean:
	/bin/rm -f $(EXECUTABLE)$(BSUFFIX) $(EXECUTABLE)$(OSUFFIX) $(GENERATED)
	/bin/rm -f *.cmi *.cmx *.cmo *.o *~ .*~ *.automaton *.conflicts *.annot
	/bin/rm -f *.d

